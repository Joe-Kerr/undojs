!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.undojs=e():t.undojs=e()}(window,function(){return function(t){var e={};function n(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(o,r,function(e){return t[e]}.bind(null,r));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=0)}([function(t,e,n){"use strict";function o(){this.commandNames={},this.commands=[],this.commandStack=[],this.batch=[],this.undoQueue=[],this.pendingUndos=0,this.processingCacheState={},this.processingUndoState=null,this.undoing=!1,this.aborting=!1,this.stackLimit=0,this.nextId=1,this.batchRecording=!1}n.r(e),o.prototype.register=function(t){if(void 0===t||void 0===t.name||void 0===t.execute||void 0===t.undo)throw new Error("Insufficient parameters in register(). Expected object with properties: <string>name, <func>execute, <func>undo. Got: "+JSON.stringify(t));if("function"!=typeof t.execute||"function"!=typeof t.undo||void 0!==t.cache&&"function"!=typeof t.cache)throw new Error("Parameter properties execute, undo and cache must be of type function");if(this.commandNames.hasOwnProperty(t.name))throw new Error("Tried to register existing command: "+t.name);const e=t.cache||null,n=t.context||null,o=this.commands.push({execute:t.execute,context:n,undo:t.undo,cache:e})-1;this.commandNames[t.name]=o},o.prototype.recordBatch=function(t){if(!(t instanceof Array))throw new Error("recordBatch requires an array of command functions.");if(0===t.length)throw new Error("recordBatch received an empty array.");const e=[];return this.batch.push([]),t.forEach(n=>{if("object"!=typeof n)throw new Error("Element of array parameter of recordBatch must be of type object. Got: "+JSON.stringify(t));if(void 0===n.name)throw new Error("Element of array parameter of recordBatch must have property name (of the command).");const o={name:n.name,batch:this.batch.length-1},r=this.execute(o,n.params);e.push(r)}),e},o.prototype._parseCommandInfo=function(t){const e=typeof t,n="Failed to execute command: ";if("string"===e)return{name:t,context:null};if("object"===e){if(void 0===t.name)throw new Error(n+"provide a name on the command info object or the name as a string instead of an object.");const e=typeof t.context;if("undefined"!==e&&"object"!==e)throw new Error(n+"context needs to be of type object");return t}throw new Error(n+"call with .execute(name<string>) or .execute({name<string>}<object>))")},o.prototype._verifyCommandExecution=function(t){if(this.undoing)throw new Error("Tried to execute a command from within undo process: command '"+t+"'");if(!this.commandNames.hasOwnProperty(t))throw new Error("Unknown command: "+t)},o.prototype._writeBatchInfoOfAsync=function(t,e){const n=this.batch[e],o=this.commandStack[this.commandStack.length-2];(0===n.length||n.indexOf(o.id)>-1)&&n.push(t)},o.prototype._writeBatchInfoOfSync=function(t,e){this.batch[e].push(t)},o.prototype.execute=async function(t,e){const{name:n,context:o}=this._parseCommandInfo(t);this._verifyCommandExecution(n);const r=this.nextId++,c=this.commandNames[n],i=this.commands[c],a=void 0===e?[]:e instanceof Array?e:[e],s=null!==o?o:i.context,h=null!==i.cache?i.cache.call(s,a):async()=>{};if(this.processingCacheState[r]=h,await h,delete this.processingCacheState[r],this.aborting)return;const u=i.execute.apply(s,a),d=void 0!==u&&void 0!==u.then,m="number"==typeof t.batch;return!0===d?u.then(e=>{this.commandStack.push({id:r,index:c,params:a,returned:e,cached:h}),m&&this._writeBatchInfoOfAsync(r,t.batch)}).catch(t=>t):(this.commandStack.push({id:r,index:c,params:a,returned:u,cached:h}),m&&this._writeBatchInfoOfSync(r,t.batch)),u},o.prototype._enqueuedPendingUndo=async function(t){return new Promise((e,n)=>{t.unshift([e,n])})},o.prototype._asyncProcessPendingUndos=async function(t){const e=t.pop();try{e[0](await this.undo(!1))}catch(t){e[1](t)}},o.prototype._undoSingleCommand=async function(t,e,n){const o=t.pop();let r,c=!1;try{r=await e[o.index].undo(o.params,o.returned,o.cached)}catch(t){c=!0,r=t}return{response:r,hasErrors:c}},o.prototype._undoBatchCommand=async function(t,e,n){const o=n.pop().length,r=[];let c=[],i=!1;for(let n=0;n<o;n++){const n=t.pop();let o;try{"object"==typeof(o=e[n.index].undo(n.params,n.returned,n.cached))&&"function"==typeof o.catch&&o.catch(t=>(i=!0,t))}catch(t){o=Promise.reject(t),i=!0}r.push(o)}return{response:c=await Promise.all(r.map(t=>Promise.resolve(t).then(t=>t,t=>t))),hasErrors:i}},o.prototype._checkIsUndoOfBatchCommand=function(t,e){const n=t[t.length-1]||[],o=e[e.length-1].id;return n.indexOf(o)>-1},o.prototype.undo=async function(t=!0){if(this.undoQueue.length>this.commandStack.length)throw new Error("There are more undos pending than on the command stack.");if(0===this.commandStack.length)return;const e=!0===this.undoing&&!0===t;if(e&&this.undoQueue.length+1>this.commandStack.length)return;if(e)return this._enqueuedPendingUndo(this.undoQueue);let n;this.undoing=!0,this.processingUndoState=new Promise(t=>{n=t});const o=!1===this._checkIsUndoOfBatchCommand(this.batch,this.commandStack)?"_undoSingleCommand":"_undoBatchCommand",r=await this[o](this.commandStack,this.commands,this.batch);let{response:c,hasErrors:i}=r;return i&&(c=Promise.reject(c),this.undoQueue=[]),n(!0),this.processingUndoState=null,this.undoing=!1,this.undoQueue.length>0&&this._asyncProcessPendingUndos(this.undoQueue),c},o.prototype.reset=async function(){this.aborting=!0,this.commandStack.splice(0,this.commandStack.length),this.batch=[],this.undoQueue=[],this.pendingUndos=0,this.undoing=!1;let t=!1;try{await Promise.all(Object.values(this.processingCacheState))}catch(e){t=!0}try{await this.processingUndoState}catch(e){t=!0}this.aborting=!1,t&&(this.processingCacheState={},this.processingUndoState=null)},o.prototype.destroy=async function(){await this.reset(),this.commandNames={},this.commands=[]};var r=o;n.d(e,"Undojs",function(){return r});e.default=r}])});